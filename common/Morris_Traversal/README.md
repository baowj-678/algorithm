# Morris算法

### 简介：

**Morris算法**可以用$\Omicron{(n)}$的*时间复杂度*和$\Omicron{(1)}$的*空间复杂度*，实现对二叉树的**先序**、**中序**、**后序**遍历。



### 算法详解：

#### 先序遍历：

* 如果**当前节点**（cur）的**左子节点**为空，【输出当前节点】，将**当前节点**的**右子节点**设为**当前节点**（cur=cur.right）；
* 如果**当前节点**（cur）的**左子节点**不为空，找到**当前节点**的**左子树**的**最右节点**（pre）（即，**当前节点**的*中序遍历*的*前驱节点*）；
  * 如果**最右节点**的**右子节点**为空，【输出当前节点】，将**当前节点**设为该节点的**右子节点**；
  * 如果**最右节点**的**右子节点**不为空，将该节点的**右子节点**设为空，将**当前节点**的**右子节点**设为**当前节点**；



****

#### 中序遍历：

* 如果**当前节点**（cur）的**左子节点**为空，【输出当前节点】，将**当前节点**的**右子节点**设为**当前节点**（cur=cur.right）；
* 如果**当前节点**（cur）的**左子节点**不为空，找到**当前节点**的**左子树**的**最右节点**（pre）（即，**当前节点**的*中序遍历*的*前驱节点*）；
  * 如果**最右节点**的**右子节点**为空，将**当前节点**设为该节点的**右子节点**；
  * 如果**最右节点**的**右子节点**不为空，将该节点的**右子节点**设为空，【输出当前节点】，将**当前节点**的**右子节点**设为**当前节点**；

#### 后序遍历：

* 如果**当前节点**（cur）的**左子节点**为空，将**当前节点**的**右子节点**设为**当前节点**（cur=cur.right）；
* 如果**当前节点**（cur）的**左子节点**不为空，找到**当前节点**的**左子树**的**最右节点**（pre）（即，**当前节点**的*中序遍历*的*前驱节点*）；
  * 如果**最右节点**的**右子节点**为空，将**当前节点**设为该节点的**右子节点**；
  * 如果**最右节点**的**右子节点**不为空，将该节点的**右子节点**设为空，【**倒序输出**当前节点的左子节点（包括），到**最右节点**（包括）路径上所有节点】，将**当前节点**的**右子节点**设为**当前节点**；